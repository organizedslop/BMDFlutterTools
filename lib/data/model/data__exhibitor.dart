/*
 * Exhibitor Data
 *
 * Generated by: ChatGPT
 * Description: Model for exhibitor JSON payload
 */

import 'dart:convert';
import 'dart:typed_data';
import 'package:bmd_flutter_tools/data/model/data__booth.dart';
import 'package:bmd_flutter_tools/data/model/enum__location_encoding.dart';
import 'package:bmd_flutter_tools/utilities/print_utilities.dart';

/// Model representing a single exhibitor.
class ExhibitorData {
  String id;
  String companyId;
  String companyName;
  String? companyDescription;
  String? logoUrl;
  List<String> categories;
  List<BoothData> booths;
  String showId;

  ExhibitorData({
    required this.id,
    required this.companyId,
    required this.companyName,
    this.companyDescription,
    this.logoUrl,
    required this.showId,
    List<String>? categories,
    List<BoothData>? booths,
  })  : categories = categories ?? <String>[],
        booths = booths ?? <BoothData>[];

  @override
  bool operator ==(Object other) {
    return other is ExhibitorData &&
        other.id == id &&
        other.companyId == companyId &&
        other.companyName == companyName &&
        other.companyDescription == companyDescription &&
        other.logoUrl == logoUrl &&
        other.showId == showId &&
        _listEquals(other.categories, categories) &&
        _listEquals(other.booths, booths);
  }

  @override
  int get hashCode => Object.hash(
        id,
        companyId,
        companyName,
        companyDescription,
        logoUrl,
        showId,
        Object.hashAll(categories),
        Object.hashAll(booths),
      );

  /// toJson with correct encoding for both API and database
  Map<String, dynamic> toJson({required LocationEncoding destination}) {
    final bool api = destination == LocationEncoding.api;
    return {
      (api ? ExhibitorDataInfo.id.jsonName : ExhibitorDataInfo.id.columnName): id,
      (api ? ExhibitorDataInfo.companyId.jsonName : ExhibitorDataInfo.companyId.columnName): companyId,
      (api ? ExhibitorDataInfo.companyName.jsonName : ExhibitorDataInfo.companyName.columnName): companyName,
      (api ? ExhibitorDataInfo.companyDescription.jsonName : ExhibitorDataInfo.companyDescription.columnName): companyDescription,
      (api ? ExhibitorDataInfo.logoUrl.jsonName : ExhibitorDataInfo.logoUrl.columnName): logoUrl,
      (api ? ExhibitorDataInfo.showId.jsonName : ExhibitorDataInfo.showId.columnName): showId,

      // Categories: API = raw List<String>, DB = JSON string
      (api ? ExhibitorDataInfo.categories.jsonName : ExhibitorDataInfo.categories.columnName):
          api ? categories : json.encode(categories),
      // Booths: API = List<Map>, DB = Uint8List (BLOB)
      (api ? ExhibitorDataInfo.booths.jsonName : ExhibitorDataInfo.booths.columnName):
          api
              ? booths.map((b) => b.toJson(destination: LocationEncoding.api)).toList()
              : (booths.isEmpty
                  ? Uint8List(0)
                  : Uint8List.fromList(
                      utf8.encode(json.encode(
                          booths.map((b) => b.toJson(destination: LocationEncoding.database)).toList(),
                      )),
                  )),
    };
  }

  /// Create an instance from JSON or database map.
  factory ExhibitorData.fromJson(
    dynamic jsonAsDynamic, {
    required LocationEncoding source,
    bool defaultOnFailure = false,
  }) {
    final bool api = source == LocationEncoding.api;
    Map<String, dynamic> map;
    if (jsonAsDynamic is String) {
      map = json.decode(jsonAsDynamic) as Map<String, dynamic>;
    } else if (jsonAsDynamic is Map) {
      map = Map<String, dynamic>.from(jsonAsDynamic);
    } else {
      logPrint('‚ùå ExhibitorData.fromJson: invalid type ${jsonAsDynamic.runtimeType}');
      if (defaultOnFailure) return ExhibitorData.empty();
      map = <String, dynamic>{};
    }

    String decodeString(String key, String fallback) {
      final value = map[key];
      return value is String ? value : fallback;
    }

    // Categories: unchanged logic (raw list or JSON string)
    List<String> decodeCategories(String key) {
      final raw = map[key];
      if (raw == null) return <String>[];
      if (raw is String) {
        try {
          final list = json.decode(raw) as List<dynamic>;
          return list.whereType<String>().toList();
        } catch (_) {
          return <String>[];
        }
      }
      if (raw is List) {
        final out = <String>[];
        for (final item in raw) {
          if (item is String && item.trim().isNotEmpty) {
            out.add(item);
          } else if (item is Map) {
            final name = item['name'];
            if (name is String && name.trim().isNotEmpty) {
              out.add(name);
            }
          }
        }
        return out;
      }
      return <String>[];
    }

    // Booths: decode as List<BoothData> depending on source
    List<BoothData> decodeBooths(String key) {
      final raw = map[key];
      if (raw == null) return <BoothData>[];
      if (api) {
        // API: expect List
        if (raw is List) {
          return raw
              .map((item) => BoothData.fromJson(item, source: LocationEncoding.api))
              .toList();
        }
        return <BoothData>[];
      } else {
        // Database: raw can be Uint8List or String
        dynamic decoded;
        if (raw is Uint8List) {
          try {
            decoded = json.decode(utf8.decode(raw));
          } catch (_) {
            return <BoothData>[];
          }
        } else if (raw is String) {
          try {
            decoded = json.decode(raw);
          } catch (_) {
            return <BoothData>[];
          }
        } else if (raw is List) {
          decoded = raw;
        }
        if (decoded is List) {
          return decoded
              .map((item) => BoothData.fromJson(item, source: LocationEncoding.database))
              .toList();
        }
        return <BoothData>[];
      }
    }

    return ExhibitorData(
      id: decodeString(
          api
              ? ExhibitorDataInfo.id.jsonName
              : ExhibitorDataInfo.id.columnName,
          ''),
      companyId: decodeString(
          api
              ? ExhibitorDataInfo.companyId.jsonName
              : ExhibitorDataInfo.companyId.columnName,
          ''),
      companyName: decodeString(
          api
              ? ExhibitorDataInfo.companyName.jsonName
              : ExhibitorDataInfo.companyName.columnName,
          ''),
        showId: decodeString(
        api
              ? ExhibitorDataInfo.showId.jsonName
              : ExhibitorDataInfo.showId.columnName,
          ''),
      companyDescription: map[api
              ? ExhibitorDataInfo.companyDescription.jsonName
              : ExhibitorDataInfo.companyDescription.columnName]
          as String?,
      logoUrl: map[api
              ? ExhibitorDataInfo.logoUrl.jsonName
              : ExhibitorDataInfo.logoUrl.columnName]
          as String?,
      categories: decodeCategories(
          api
              ? ExhibitorDataInfo.categories.jsonName
              : ExhibitorDataInfo.categories.columnName),
      booths: decodeBooths(
          api
              ? ExhibitorDataInfo.booths.jsonName
              : ExhibitorDataInfo.booths.columnName),
    );
  }

  /// Empty instance.
  factory ExhibitorData.empty() => ExhibitorData(
        id: '',
        companyId: '',
        companyName: '',
        showId: "",
      );
}

/// Enum of columns and JSON keys for ExhibitorData
const String blobType = 'BLOB';
enum ExhibitorDataInfo {
  id('id', 'id', 'ID', idType),
  companyId('company_id', 'company_id', 'Company ID', textType),
  companyName('company_name', 'company_name', 'Company Name', textType),
  companyDescription('company_description', 'company_description', 'Description', textType),
  logoUrl('logo_url', 'logo_url', 'Logo URL', textType),
  categories('categories', 'categories', 'Categories', textType),
  booths('booths', 'booths', 'Booths', blobType),
  showId('show_id', 'show_id', 'Show ID', 'TEXT NOT NULL');

  final String columnName;
  final String jsonName;
  final String displayName;
  final String columnType;

  static const String idType = 'TEXT PRIMARY KEY';
  static const String textType = 'TEXT';
  // blobType defined above

  const ExhibitorDataInfo(
      this.columnName, this.jsonName, this.displayName, this.columnType);

  static String get tableName => 'exhibitors';

  static String get tableBuilder {
    final cols = ExhibitorDataInfo.values
        .map((e) => '${e.columnName} ${e.columnType}')
        .join(', ');
    return 'CREATE TABLE IF NOT EXISTS $tableName ($cols)';
  }
}

// Helper for list equality (works for List<BoothData> too)
bool _listEquals<T>(List<T>? a, List<T>? b) {
  if (a == null && b == null) return true;
  if (a == null || b == null) return false;
  if (identical(a, b)) return true;
  if (a.length != b.length) return false;
  for (int i = 0; i < a.length; i++) {
    if (a[i] != b[i]) return false;
  }
  return true;
}